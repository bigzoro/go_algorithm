package main

import (
	"fmt"
)

func Test01(arr []int) {
	temp := 0
	// 冒牌排序要排序的次数： 假设有N个元素，那么需要进行N-1次排序

	//----------------------第一次比较---------------
	for i := 0; i < len(arr)-1; i++ {
		if arr[i] > arr[i+1] {
			temp = arr[i]
			arr[i] = arr[i+1]
			arr[i+1] = temp
		}
	}
	fmt.Println(arr) // [3 -1 9 -2 10]

	/*
	   分析：
	   	原数组：[3, 9, -1, 10, -2]
	   	第一次比较后的数组：[3 -1 9 -2 10]
	   	比较第一组相邻的元素[3, 9]，查看是否交换，3小于9，不需要交换，此时数组为[3, 9, -1, 10, -2]
	   	比较第二组相邻的元素[9, -1]，查看是否需要交换，9大于-1，交换，此时数组变为[3, -1, 9, 10, -2]
	  	比较第三组相邻的元素[9, 10]，查看是否交换，9小于10，不需要交换，此时数组为[3, -1, 9, 10, -2]
	   	比较第三组相邻的元素[10, -2]，查看是否需要交换，-2小于10，需要交换，此时数组变为[3, -1, 9, -2, 10]
	*/

	//----------------------第二次比较---------------
	// 循环条件-2：因为最后一个元素已经确定为最大的了，不需要再进行比较，第一次比较减1，所以这一次减2
	for i := 0; i < len(arr)-2; i++ {
		if arr[i] > arr[i+1] {
			temp = arr[i]
			arr[i] = arr[i+1]
			arr[i+1] = temp
		}
	}
	fmt.Println(arr) // [-1 3 -2 9 10]
	/*
		分析：
			第一次比较后的数组：[3 -1 9 -2 10]
			第二次比较后的数组：[-1 3 -2 9 10]
			比较第一组相邻的元素[-1, 3]，查看是否交换，3大于-1，需要交换，此时数组为[-1 3 9 -2 10]
			比较第二组相邻的元素[3, 9]，查看是否需要交换，3小于9，不需要交换，此时数组变为[-1 3 9 -2 10]
			比较第三组相邻的元素[9, -2]，查看是否交换，-2小于9，需要交换，此时数组变为[-1 3 -2 9 10]
			因为最后一个元素已经为最大了，不需要再比较
	*/

	//----------------------第三次比较---------------
	for i := 0; i < len(arr)-3; i++ {
		if arr[i] > arr[i+1] {
			temp = arr[i]
			arr[i] = arr[i+1]
			arr[i+1] = temp
		}
	}
	fmt.Println(arr) // [-1 -2 3 9 10]

	/*
		分析：
			第二次比较后的数组：[-1 3 -2 9 10]
			第三次比较后的数组：[-1 -2 3 9 10]
			比较第一组相邻的元素[-1, 3]，查看是否交换，-1大于3，不需要交换，此时数组为[-1 3 9 -2 10]
			比较第二组相邻的元素[3, -2]，查看是否需要交换，3大于-2，需要交换，此时数组变为[-1 -2 3 9 10]
			因为最后两个个元素已经为最大了，不需要再比较
	*/

	// 此时数组已经有序，不需要再进行比较了

}

// 使用双层循环进行冒泡排序
func Test02(arr []int) {
	temp := 0

	// 外层循环控制进行n-1趟扫描
	for i := 0; i < len(arr)-1; i++ {
		// 内层循环进行比较和交换
		for j := 0; j < len(arr)-1-i; j++ {
			if arr[j] > arr[j+1] {
				temp = arr[j]
				arr[j] = arr[j+1]
				arr[j+1] = temp
			}
		}
	}

	fmt.Println(arr)
}

// 对冒泡排序进行优化
func Test03(arr []int) {
	temp := 0

	// 控制是否继续循环
	flag := false
	// 外层循环控制进行n-1趟扫描
	for i := 0; i < len(arr)-1; i++ {
		// 内层循环进行比较和交换
		for j := 0; j < len(arr)-1-i; j++ {
			if arr[j] > arr[j+1] {
				temp = arr[j]
				arr[j] = arr[j+1]
				arr[j+1] = temp

				flag = true
			}
		}
		// 没有进行交换，说明数组已有序
		if !flag {
			break
		}
	}

	fmt.Println(arr)
}
func main() {

	// 从小到大排序
	arr := []int{3, 9, -1, 10, -2}

	// Test01(arr)

	// Test02(arr)

	Test03(arr)
}
